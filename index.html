<style>
    * {
        margin: 0;padding: 0;font-family: sans-serif;
    }
</style>
<div id="info"></div>
<canvas id="a" style="background:#111517"></canvas>
<script src="jsToolBox/v2d.js"></script>
<script src="jsToolBox/pool.js"></script>
<script src="levelOne.js"></script>
<script>
    tiles = {
        0 : "#000000",
        1 : "#FFFFFF",
        2 : "#c3f245",
    }
</script>
<script>
    
    /* 
    
        - map
        - //player fire
        - //bullet class
        - //real pool with pivot
        - //bullet disapears
            - //on collision
                - with map
                - player
                - red guys
        - red guys have wearpons
        - collision
        - player action update time dilatation for a moment
        - red ia & roles
            - a star
        - mission editor
    
    */
// a: canvas
// b: body
    var map = TileMaps.levelOne
    
    b = document.body
    a.width = innerWidth;
    a.height = innerHeight;
    c = a.getContext("2d")
    
    
    TILE_SIZE = map.tilewidth
    RED_MULTIPLIER = 0.1
    BULLET_MULTIPLIER = 0.8
    TIME_STEP = 1
    TIME_LIMIT = 20
    MIN_SPEED = 1
    ENTITY_SIZE = 40
    BULLET_SIZE = 5
    PLAYER_PISTOL_CD = 50
    BULLET_POOL_SIZE = 20
    MAX_RED_GUYS = 20
    RED_GUYS_CD = 1500
    RED_GUYS_SPAWN_CD = 1000
    SOUND_WAVE_TIME = 300
    CELL_SIZE = 10
    CELL_TIME = 50
    SOUND_CD = 300
    SOUND_PROPAGATIONS_SPEED = 0.1
    
    PII = 2 * Math.PI
    

    // c: canvas context2d
    // p: player x | y | pistol cd |Â current w cd
    p = [0,0, -1]
    pv = [0,0]
    // t: time dilatation
    t = 1
    // e: elapsed time
    e = 0
    // r: red guys
    // 1 : cac | 2 : pistol | 3 : shotgun | 4 : auto
    r = []
    // u: bullets
   // bullets = new Pool(100, Bullet)
    u = []
    bi = 0// last bullet index
    // f: is fireing
    f = false
    // m: mouse pos
    m = [0,0]
    /* cells for bullets marks */
    cells = Object.create(null)
    collidables = []
    
    foyers = Object.create(null)
    //soundWaves = Object.create(null)
    // CONTROLS
    
    
    /* wasd by xem */
    U=D=L=R=0;onkeyup=T=(e,v)=>top['LURDL*D*L*UR*U'[(e.which-37)%20]]=v;onkeydown=e=>T(e,1)
    /* pause */
    window.onkeypress = function(e) {
        if(e.which === 32 && loopHandler) {// space pause 
            clearInterval(loopHandler)
            loopHandler = 0
            c.font = '48px sans-serif'
            c.fillStyle = 'black'
            c.fillText('PAUSE', a.width / 2 -  60, a.height / 2, a.width)
        } else if(e.which === 32 && !loopHandler) {
            loopHandler = setInterval(l,16)
        }
    }
    
    b.onmousedown = function(e) {
        f = true
    }
    
    b.onmouseup = function(e) {
        f = false
    }
    
    b.onmousemove = function(e) {
        m[0] = e.x
        m[1] = e.y - e.target.offsetTop
    }
    
    loadEntities()
    var t0 = 0;
    var t1 = 0;
    function l() {
        var t0 = performance.now();
        /* draw map */
        
        a.width += 0
        drawMap()
        /* move player */
        
        p[1] = D ? p[1] + t : p[1]
        p[1] = U ? p[1] - t : p[1]
        
        p[0] = R ? p[0] + t : p[0]
        p[0] = L ? p[0] - t : p[0]
        
        
        for(var i = 0; i < collidables.length; i++) {
            var collidable = collidables[i]
            
            
            
                
            
            if(R) { // ->
                if(p[0] > collidable.x && p[0] < collidable.x+TILE_SIZE
                &&
                p[1] > collidable.y && p[1] < collidable.y+TILE_SIZE) {
                    p[0] = collidable.x
                } 
            } else if(L) { // <-
                if(p[0] > collidable.x && p[0] < collidable.x+TILE_SIZE
                &&
                p[1] > collidable.y && p[1] < collidable.y+TILE_SIZE) {
                    p[0] = collidable.x + TILE_SIZE
                } 
            } 
           /* if(U) {
                 if(p[1] > collidable.x && p[0] < collidable.x+TILE_SIZE
                &&
                p[1] > collidable.y && p[1] < collidable.y+TILE_SIZE) {
                    p[0] = collidable.x + TILE_SIZE
                } 
            }*/
            
            //collidable.y 
        }
        
        /* draw player */
        c.fillStyle = "#FFFFFF"
        c.fillRect(p[0]-ENTITY_SIZE/2,p[1]-ENTITY_SIZE/2, ENTITY_SIZE, ENTITY_SIZE)
        
        /* player fire */
        if(p[2]<0 && f) {
            p[2] = PLAYER_PISTOL_CD
            addBullet(p,m,0)
        } else {
            p[2]--
        }

        /* draw red guy */
        c.fillStyle = "#CC0000"
        r.forEach(function(g) {
            g.draw()
            g.tick()
        })
        
        for(var i = 0; i < BULLET_POOL_SIZE; i++) {
            var bullet = u[i]
            if(bullet) { 
                bullet[0] = bullet[0] - bullet[4] * t * BULLET_MULTIPLIER 
                bullet[1] = bullet[1] - bullet[5] * t * BULLET_MULTIPLIER

                if(stance(bullet, p) < 5) {
                   // u[i] = false

                }
                u.forEach(function(red, redPos) {
                    if(stance([red.x, red.y], bullet) < 5) {
                        red.alive = false
                    }
                })

                Cell(bullet[0], bullet[1])
            }
            
        }
        
        /* draw cells */
        for(var cellKey in cells) {
            var cell = cells[cellKey];
            if(cell.t < 0) {
                delete cells[cellKey]
            } else {
                cell.t--
            }
            drawCell(cell)
        }
        /* draw sound wave */
        /*for(var cellKey in soundCells) {
            var cell = soundCells[cellKey];
            if(cell.t < 0) {
                delete cells[cellKey]
            } else {
                cell.t--
            }
        }
        
        for(var soundCellKey in soundCells) {
            var soundCell = soundCells[soundCellKey]
            if(soundCell.t < 0) {
                soundCell --
                startWave(soundCell)
            } else {
                soundCell ++
            }
        }
        
        */
        
        /* recalc time dilatation */
        t = (U || L || R || D) ? (t += TIME_STEP) : MIN_SPEED
        t = t > TIME_LIMIT ? TIME_LIMIT : t
        /* add elapsed time */
        e+=t
        cleanBullets()
        /* show some data */
        t1 = performance.now();
        /* draw sound wave */
        SoundWave.drawAll()
        console.log("Call to doSomething took " + (t1 - t0) + " milliseconds.");
        info.innerHTML = "speed : " + t + "<br>time : " + e + "<br>take :" + (t1 - t0) 
        
    }
    var loopHandler = setInterval(l,16)
    
    
    function stance(a, b) {
        return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])) 
    } 
    
    function addBullet(from, to, color) {
        for(var i = 0; i < BULLET_POOL_SIZE; i ++ ) {
            if(!u[i]) {
                var bulletStance = stance(from, to)
                u[i] = [from[0], from[1], from[0], from[1], (from[0] - to[0]) / bulletStance, (from[1] - to[1]) / bulletStance, color]
                return
            }
        }
    }
    
    function cleanBullets() {
        for(var i =0; i < BULLET_POOL_SIZE; i ++) {
            if(u[i] && (u[i][0] < 0 || u[i][0] > a.width || u[i][1] < 0 || u[i][1] > a.height)) {
                u[i] = false
            }
        }
    }
    
    
    function loadEntities() {
        map.layers[1].objects.forEach(function(entity) {
            if(entity.name === 'start') {
                p = [entity.x, entity.y, 0]
            } else if(entity.name === 'red') {
                r.push(new Red(entity.x, entity.y, entity.properties.spawnTime))
            }
        })
        
       for(var i = 0; i < map.width; i ++) {
            for(var j = 0; j < map.height; j ++) {
                tile = map.layers[0].data[i+j*100]
                if(tile === 1) {
                   collidables.push({x : i*TILE_SIZE, y : j*TILE_SIZE})
                }
            }
        }
    }
    
    function drawMap() {
        for(var i = 0; i < map.width; i ++) {
            for(var j = 0; j < map.height; j ++) {
                tile = map.layers[0].data[i+j*100]
                if(tile) {
                    c.fillStyle = tiles[tile]
                    c.fillRect(i*TILE_SIZE, j*TILE_SIZE, TILE_SIZE, TILE_SIZE)
                }
            }
        }
    }
    
    function Red(x,y, spawnTime) {
        this.alive = false; 
        this.isFoyer = true  
        this.spawnTime = spawnTime
        this.x = x
        this.y = y
        this.cd = 0
        
        foyers[this.x+'_'+this.y] = new SoundWave(this.x, this.y)
    }
    
    Red.prototype.draw = function() {
        if(this.alive) {
            c.fillRect(this.x-ENTITY_SIZE/2,this.y-ENTITY_SIZE/2,ENTITY_SIZE,ENTITY_SIZE)
        }
    }
    
    
    Red.prototype.tick = function() {
        if(this.alive) {
            
            //this.tileX = Math.floot(this.x / TILE_SIZE)
            //this.tileY = Math(this.y / TILE_SIZE)
            
            /* move */
            var aimPlayerVectorStance = stance(p,[this.x, this.y])
            this.x += (p[0] - this.x) / aimPlayerVectorStance * t * RED_MULTIPLIER
            this.y += (p[1] - this.y) / aimPlayerVectorStance * t * RED_MULTIPLIER
            
            //this.newTileX = Math(this.x / TILE_SIZE)
            //this.newTileY = Math(this.y / TILE_SIZE)
            //if(this.tileX != this.newTileX || this.tileY != this.newTileY) {
                // tile changed
                
                
            
            
            /* fire */
            if(this.cd < 1) {
                this.cd = PLAYER_PISTOL_CD
                addBullet([this.x,this.y],p,0)
            } else {
                this.cd --
            }
        
        } else if(this.spawnTime < e) {
            this.alive = true
        }
       
    }
    
    function Bullet() {
        
    }

    var tmpCellX = 0
    var tmpCellY = 0
    
    function Cell(x,y) {
        tmpCellX = Math.floor((x-CELL_SIZE) / CELL_SIZE)
        tmpCellY = Math.floor((y-CELL_SIZE) / CELL_SIZE)
        cells[tmpCellX + '_' + tmpCellY] = {
            x : tmpCellX,
            y : tmpCellY,
            t : CELL_TIME
        }
    }
    
    function drawCell(cell) {
        c.fillStyle = "hsla(0, 100%, 25%, "+(cell.t/100)+")" 
        c.fillRect(cell.x*CELL_SIZE, cell.y*CELL_SIZE, CELL_SIZE, CELL_SIZE)
    }
    
    
    function SoundWave(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 0;
    }
    
    SoundWave.prototype.tick = function() {
        this.radius += SOUND_PROPAGATIONS_SPEED * t
        this.draw()
        
        
        //cells[tmpCellX]
    }
    
    SoundWave.prototype.draw = function() {
        c.beginPath()
        c.arc(this.x, this.y, this.radius, 0, PII)
        c.strokeStyle = "red";
        c.lineWidth = 2;
        c.stroke()
    }
    
    SoundWave.drawAll = function() {
        for(var foyerKey in foyers) {
            var foyer = foyers[foyerKey]
            foyer.tick()
            if(foyer.radius > 100) {
                delete foyers[foyerKey]
            } else {
                foyer.draw()
            }
        }
    }
    
    
</script>