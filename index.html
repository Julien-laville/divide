<style>
    * {
        margin: 0;padding: 0;font-family: sans-serif;
    }
</style>
<div id="info"></div>
<canvas id="a" style="background:#111517"></canvas>
<script src="jsToolBox/v2d.js"></script>
<script src="jsToolBox/pool.js"></script>


<script src="src/player.js"></script>
<script src="src/red.js"></script>
<script src="src/bullet.js"></script>
<script src="src/map.js"></script>

<script src="levelOne.js"></script>
<script>
    tiles = {
        0 : "#000000",
        1 : "#FFFFFF",
        2 : "#c3f245",
    }
</script>
<script>
    
    /* 
    
        - map
        - //player fire
        - //bullet class
        - //real pool with pivot
        - //bullet disapears
            - //on collision
                - with map
                - player
                - red guys
        - split & es6
        - red guys have wearpons
        - collision
        - player action update time dilatation for a moment
        - red ia & roles
            - a star
        - mission editor
    
    */
// a: canvas
// b: body
    
    b = document.body
    a.width = innerWidth;
    a.height = innerHeight;
    c = a.getContext("2d")
    
    
    TILE_SIZE = TileMaps.levelOne.tilewidth
    RED_MULTIPLIER = 0.1
    BULLET_MULTIPLIER = 0.8
    TIME_STEP = 1
    TIME_LIMIT = 20
    MIN_SPEED = 1
    ENTITY_SIZE = 40
    BULLET_SIZE = 5
    PLAYER_PISTOL_CD = 50
    BULLET_POOL_SIZE = 20
    MAX_RED_GUYS = 20
    RED_GUYS_CD = 1500
    RED_GUYS_SPAWN_CD = 1000
    SOUND_WAVE_TIME = 300
    CELL_SIZE = 10
    CELL_TIME = 50
    SOUND_CD = 300
    

    // c: canvas context2d
    // p: player x | y | pistol cd |Â current w cd
    const player = new Player(0,0)
    // t: time dilatation
    t = 1
    // e: elapsed time
    e = 0
    // r: red guys
    // 1 : cac | 2 : pistol | 3 : shotgun | 4 : auto
    const reds = new Pool(10,RedGuy)
    // u: bullets
   // bullets = new Pool(100, Bullet)
    const bullets = new Pool(Bullet)
    
    const map = new Map()
    bi = 0// last bullet index
    // f: is fireing
    f = false
    // m: mouse pos
    m = [0,0]
    /* cells for bullets marks */
    cells = Object.create(null)
    soundCells = Object.create(null)
    collidables = []
    
    foyers = Object.create(null)
    soundCells = Object.create(null)
    // CONTROLS
    
    
    /* wasd by xem */
    U=D=L=R=0;onkeyup=T=(e,v)=>top['LURDL*D*L*UR*U'[(e.which-37)%20]]=v;onkeydown=e=>T(e,1)
    /* pause */
    window.onkeypress = function(e) {
        if(e.which === 32 && loopHandler) {// space pause 
            clearInterval(loopHandler)
            loopHandler = 0
            c.font = '48px sans-serif'
            c.fillStyle = 'black'
            c.fillText('PAUSE', a.width / 2 -  60, a.height / 2, a.width)
        } else if(e.which === 32 && !loopHandler) {
            loopHandler = setInterval(l,16)
        }
    }
    
    b.onmousedown = function(e) {
        f = true
    }
    
    b.onmouseup = function(e) {
        f = false
    }
    
    b.onmousemove = function(e) {
        m[0] = e.x
        m[1] = e.y - e.target.offsetTop
    }
    
    map.load(TileMaps.levelOne, player, reds)
    var t0 = 0;
    var t1 = 0;
    function l() {
        var t0 = performance.now();
        /* draw map */
        
        a.width += 0
        map.draw()
        /* move player */
        
       player.move()
        /*
        for(var i = 0; i < collidables.length; i++) {
            var collidable = collidables[i]
            
            
            
                
            
            if(R) { // ->
                if(p[0] > collidable.x && p[0] < collidable.x+TILE_SIZE
                &&
                p[1] > collidable.y && p[1] < collidable.y+TILE_SIZE) {
                    p[0] = collidable.x
                } 
            } else if(L) { // <-
                if(p[0] > collidable.x && p[0] < collidable.x+TILE_SIZE
                &&
                p[1] > collidable.y && p[1] < collidable.y+TILE_SIZE) {
                    p[0] = collidable.x + TILE_SIZE
                } 
            } 
            if(U) {
                 if(p[1] > collidable.x && p[0] < collidable.x+TILE_SIZE
                &&
                p[1] > collidable.y && p[1] < collidable.y+TILE_SIZE) {
                    p[0] = collidable.x + TILE_SIZE
                } 
            }
            
            //collidable.y 
        }*/
        
        player.draw()
        player.fire()
        
        

        /* draw red guy */
        for(let i = 0; i < reds.pivot; i ++) {
            let red = reds.pool[i]
            red.draw()
            red.tick()
        }
        /*
        for(var i = 0; i < BULLET_POOL_SIZE; i++) {
            var bullet = u[i]
            if(bullet) { 
                bullet[0] = bullet[0] - bullet[4] * t * BULLET_MULTIPLIER 
                bullet[1] = bullet[1] - bullet[5] * t * BULLET_MULTIPLIER

                if(stance(bullet, p) < 5) {
                   // u[i] = false

                }
                u.forEach(function(red, redPos) {
                    if(stance([red.x, red.y], bullet) < 5) {
                        red.alive = false
                    }
                })

                Cell(bullet[0], bullet[1])
            }
            
        }*/
        
        /* draw cells */
        for(var cellKey in cells) {
            var cell = cells[cellKey];
            if(cell.t < 0) {
                delete cells[cellKey]
            } else {
                cell.t--
            }
            drawCell(cell)
        }
        /* draw sound wave */
        for(var cellKey in soundCells) {
            var cell = soundCells[cellKey];
            if(cell.t < 0) {
                delete cells[cellKey]
            } else {
                cell.t--
            }
        }
        
        for(var soundCellKey in soundCells) {
            var soundCell = soundCells[soundCellKey]
            if(soundCell.t < 0) {
                soundCell --
                startWave(soundCell)
            } else {
                soundCell ++
            }
        }
        
    
        
        /* recalc time dilatation */
        t = (U || L || R || D) ? (t += TIME_STEP) : MIN_SPEED
        t = t > TIME_LIMIT ? TIME_LIMIT : t
        /* add elapsed time */
        e+=t
        cleanBullets()
        /* show some data */
        t1 = performance.now();
        console.log("Call to doSomething took " + (t1 - t0) + " milliseconds.");
        info.innerHTML = "speed : " + t + "<br>time : " + e + "<br>take :" + (t1 - t0) 
        
    }
    var loopHandler = setInterval(l,16)
    
    
    function stance(a, b) {
        return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])) 
    } 
    
    function addBullet(from, to, color) {
        for(var i = 0; i < BULLET_POOL_SIZE; i ++ ) {
            if(!u[i]) {
                var bulletStance = stance(from, to)
                u[i] = [from[0], from[1], from[0], from[1], (from[0] - to[0]) / bulletStance, (from[1] - to[1]) / bulletStance, color]
                return
            }
        }
    }
    
    function cleanBullets() {
        for(var i =0; i < BULLET_POOL_SIZE; i ++) {
            if(u[i] && (u[i][0] < 0 || u[i][0] > a.width || u[i][1] < 0 || u[i][1] > a.height)) {
                u[i] = false
            }
        }
    }
    



    var tmpCellX = 0
    var tmpCellY = 0
    
    function Cell(x,y) {
        tmpCellX = Math.floor((x-CELL_SIZE) / CELL_SIZE)
        tmpCellY = Math.floor((y-CELL_SIZE) / CELL_SIZE)
        cells[tmpCellX + '_' + tmpCellY] = {
            x : tmpCellX,
            y : tmpCellY,
            t : CELL_TIME
        }
    }
    
    function drawCell(cell) {
        c.fillStyle = "hsla(0, 100%, 25%, "+(cell.t/100)+")" 
        c.fillRect(cell.x*CELL_SIZE, cell.y*CELL_SIZE, CELL_SIZE, CELL_SIZE)
    }
    
</script>