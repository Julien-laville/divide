<style>
    * {
        margin: 0;padding: 0;font-family: sans-serif;
    }
</style>
<div id="i"></div>
<canvas id="a" style="background:#111517"></canvas>
<script src="jsToolBox/v2d.js"></script>
<script src="jsToolBox/pool.js"></script>
<script src="levelOne.js"></script>
<script>
    tiles = {
        1 : "#FFFFFF"
    }
</script>
<script>
    
    /* 
    
        - map
        - //player fire
        - //bullet disapears
        - bullet class
        - real pool with pivot
            - //on collision
                - with map
                - player
                - red guys
        - red guys have wearpons
        - collision
        - player action update time dilatation for a moment
        - red ia & roles
        - mission editor
    
    */
// a: canvas
// b: body
    var map = TileMaps.levelOne
    b = document.body
    a.width = innerWidth;
    a.height = innerHeight;
    c = a.getContext("2d")
    
    RED_MULTIPLIER = 0.1
    BULLET_MULTIPLIER = 0.8
    TIME_STEP = 1
    TIME_LIMIT = 20
    MIN_SPEED = 1
    ENTITY_SIZE = 40
    BULLET_SIZE = 5
    PLAYER_PISTOL_CD = 50
    BULLET_POOL_SIZE = 20
    MAX_RED_GUYS = 20
    RED_GUYS_CD = 1500
    RED_GUYS_SPAWN_CD = 1000
    
    CELL_SIZE = 10
    CELL_TIME = 50
    

    // c: canvas context2d
    // p: player x | y | pistol cd |Â current w cd
    p = [0,0, -1]
    pv = [0,0]
    // t: time dilatation
    t = 1
    // e: elapsed time
    e = 0
    // r: red guys
    // 1 : cac | 2 : pistol | 3 : shotgun | 4 : auto
    r = []
    // u: bullets
    bullets = new Pool(100, Bullet)
    u = []
    bi = 0// last bullet index
    // f: is fireing
    f = false
    // m: mouse pos
    m = [0,0]
    /* cells for bullets marks */
    cells = Object.create(null)
    
    // CONTROLS
    
    
    /* wasd by xem */
    U=D=L=R=0;onkeyup=T=(e,v)=>top['LURDL*D*L*UR*U'[(e.which-37)%20]]=v;onkeydown=e=>T(e,1)
    
    b.onmousedown = function(e) {
        f = true
    }
    b.onmouseup = function(e) {
        f = false
    }
    
    
    b.onmousemove = function(e) {
        m[0] = e.x
        m[1] = e.y - e.target.offsetTop
    }
    loadEntities()
    
    function l() {
        /* draw map */
        
        a.width += 0
        drawMap()
        /* move player */
        
        p[1] = D ? p[1] + t : p[1]
        p[1] = U ? p[1] - t : p[1]
        
        p[0] = R ? p[0] + t : p[0]
        p[0] = L ? p[0] - t : p[0]
        /* draw player */
        c.fillStyle = "#FFFFFF"
        c.fillRect(p[0]-ENTITY_SIZE/2,p[1]-ENTITY_SIZE/2, ENTITY_SIZE, ENTITY_SIZE)
        
        /* player fire */
        if(p[2]<0 && f) {
            p[2] = PLAYER_PISTOL_CD
            addBullet(p,m,0)
        } else {
            p[2]--
        }

        /* draw red guy */
        c.fillStyle = "#CC0000"
        r.forEach(function(g) {
            g.draw()
            g.tick()
        })
        
        for(var i = 0; i < BULLET_POOL_SIZE; i++) {
            var bullet = u[i]
            if(bullet) { 
                bullet[0] = bullet[0] - bullet[4] * t * BULLET_MULTIPLIER 
                bullet[1] = bullet[1] - bullet[5] * t * BULLET_MULTIPLIER

                if(stance(bullet, p) < 5) {
                   // u[i] = false

                }
                u.forEach(function(red, redPos) {
                    if(stance([red.x, red.y], bullet) < 5) {
                        red.alive = false
                    }
                })



                /* border 
                c.lineWidth = 9
                c.strokeStyle = "hsl("+bullet[6]*360+",100%,7%)"
                c.beginPath()       
                c.moveTo(bullet[0],bullet[1]);
                c.lineTo(bullet[2],bullet[3]);
                c.stroke(); 
                center 
                c.lineWidth = 2
                c.strokeStyle = "hsl("+bullet[6]*360+",100%,85%)"
                c.moveTo(bullet[0],bullet[1]);
                c.stroke(); 
                bullet */
                Cell(bullet[0], bullet[1])
                c.fillRect(bullet[0]-BULLET_SIZE/2,bullet[1]-BULLET_SIZE/2, BULLET_SIZE,BULLET_SIZE)
            }
            
        }
        
        for(var cellKey in cells) {
            var cell = cells[cellKey];
            if(cell.t < 0) {
                delete cells[cellKey]
            } else {
                cell.t--
            }
            drawCell(cell)
        }
        
    
        
        /* recalc time dilatation */
        t = (U || L || R || D) ? (t += TIME_STEP) : MIN_SPEED
        t = t > TIME_LIMIT ? TIME_LIMIT : t
        /* add elapsed time */
        e+=t
        cleanBullets()
        /* show some data */
        i.innerHTML = "speed : " + t + "<br>time : " + e + "<br>"
    }
    setInterval(l,16)
    
    function stance(a, b) {
        return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])) 
    } 
    
    function addBullet(from, to, color) {
        for(var i = 0; i < BULLET_POOL_SIZE; i ++ ) {
            if(!u[i]) {
                var bulletStance = stance(from, to)
                u[i] = [from[0], from[1], from[0], from[1], (from[0] - to[0]) / bulletStance, (from[1] - to[1]) / bulletStance, color]
                return
            }
        }
    }
    
    function cleanBullets() {
        for(var i =0; i < BULLET_POOL_SIZE; i ++) {
            if(u[i] && (u[i][0] < 0 || u[i][0] > a.width || u[i][1] < 0 || u[i][1] > a.height)) {
                u[i] = false
            }
        }
    }
    
    function loadEntities() {
        map.layers[1].objects.forEach(function(entity) {
            if(entity.name === 'start') {
                p = [entity.x, entity.y, 0]
            } else if(entity.name === 'red') {
                r.push(new Red(entity.x, entity.y, entity.properties.spawnTime))
            }
        })
    }
    
    function drawMap() {
        for(var i = 0; i < map.width; i ++) {
            for(var j = 0; j < map.height; j ++) {
                tile = map.layers[0].data[i+j*100]
                if(tile) {
                    c.fillStyle = tiles[tile]
                    c.fillRect(i*map.tilewidth, j*map.tilewidth, map.tilewidth, map.tilewidth)
                }
            }
        }
    }
    
    function Red(x,y, spawnTime) {
        this.alive = false; 
        this.spawnTime = spawnTime
        this.x = x
        this.y = y
        this.cd = 0
    }
    
    Red.prototype.draw = function() {
        if(this.alive) {
            c.fillRect(this.x-ENTITY_SIZE/2,this.y-ENTITY_SIZE/2,ENTITY_SIZE,ENTITY_SIZE)
        }
    }
    
    Red.prototype.tick = function() {
        if(this.alive) {
            /* move */
            var aimPlayerVectorStance = stance(p,[this.x, this.y])
            this.x += (p[0] - this.x) / aimPlayerVectorStance * t * RED_MULTIPLIER
            this.y += (p[1] - this.y) / aimPlayerVectorStance * t * RED_MULTIPLIER
            
            /* fire */
            
            if(this.cd < 1) {
                this.cd = PLAYER_PISTOL_CD
                addBullet([this.x,this.y],p,0)
            } else {
                this.cd --
            }
        
        } else if(this.spawnTime < e) {
            this.alive = true
        }
       
    }
    
    function Bullet() {
        
    }

    var tmpCellX = 0
    var tmpCellY = 0
    
    function Cell(x,y) {
        tmpCellX = Math.floor((x-BULLET_SIZE/2) / CELL_SIZE)
        tmpCellY = Math.floor((y-BULLET_SIZE/2) / CELL_SIZE)
        cells[tmpCellX + '_' + tmpCellY] = {
            x : tmpCellX,
            y : tmpCellY,
            t : CELL_TIME
        }
    }
    
    function drawCell(cell) {
        c.fillStyle = "hsl(0, 100%, "+cell.t+"%)" 
        c.fillRect(cell.x*CELL_SIZE, cell.y*CELL_SIZE, CELL_SIZE, CELL_SIZE)
    }
    
    
    //Bullet.prototype.
    
   
    
</script>